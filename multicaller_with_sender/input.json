{"language":"Solidity","sources":{"MulticallerWithSender.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title MulticallerWithSender\n * @author vectorized.eth\n * @notice Contract that allows for efficient aggregation of multiple calls\n *         in a single transaction, while \"forwarding\" the `msg.sender`.\n */\ncontract MulticallerWithSender {\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev The lengths of the input arrays are not the same.\n     */\n    error ArrayLengthsMismatch();\n\n    /**\n     * @dev This function does not support reentrancy.\n     */\n    error Reentrancy();\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor() payable {\n        assembly {\n            // Throughout this code, we will abuse returndatasize\n            // in place of zero anywhere before a call to save a bit of gas.\n            // We will use storage slot zero to store the caller at\n            // bits [0..159] and reentrancy guard flag at bit 160.\n            sstore(returndatasize(), shl(160, 1))\n        }\n    }\n\n    // =============================================================\n    //                    AGGREGATION OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the address that called `aggregateWithSender` on this contract.\n     *      The value is always the zero address outside a transaction.\n     */\n    fallback() external payable {\n        assembly {\n            mstore(returndatasize(), and(sub(shl(160, 1), 1), sload(returndatasize())))\n            return(returndatasize(), 0x20)\n        }\n    }\n\n    /**\n     * @dev Aggregates multiple calls in a single transaction.\n     *      The `msg.value` will be forwarded to the last call.\n     *      This method will set `sender` to the `msg.sender` temporarily\n     *      for the span of its execution.\n     *      This method does not support reentrancy.\n     * @param targets An array of addresses to call.\n     * @param data    An array of calldata to forward to the targets.\n     * @return An array of the returndata from each call.\n     */\n    function aggregateWithSender(address[] calldata targets, bytes[] calldata data)\n        external\n        payable\n        returns (bytes[] memory)\n    {\n        assembly {\n            if iszero(eq(targets.length, data.length)) {\n                // Store the function selector of `ArrayLengthsMismatch()`.\n                mstore(returndatasize(), 0x3b800a46)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            if iszero(and(sload(returndatasize()), shl(160, 1))) {\n                // Store the function selector of `Reentrancy()`.\n                mstore(returndatasize(), 0xab143c06)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(returndatasize(), 0x20) // Store the memory offset of the `results`.\n            mstore(0x20, data.length) // Store `data.length` into `results`.\n            // Early return if no data.\n            if iszero(data.length) { return(returndatasize(), 0x40) }\n\n            // Set the sender slot temporarily for the span of this transaction.\n            sstore(returndatasize(), caller())\n\n            let results := 0x40\n            // Left shift by 5 is equivalent to multiplying by 0x20.\n            data.length := shl(5, data.length)\n            // Copy the offsets from calldata into memory.\n            calldatacopy(results, data.offset, data.length)\n            // Offset into `results`.\n            let resultsOffset := data.length\n            // Pointer to the last result.\n            let lastResults := add(0x20, data.length)\n            // Pointer to the end of `results`.\n            let end := add(results, data.length)\n\n            for {} 1 {} {\n                // The offset of the current bytes in the calldata.\n                let o := add(data.offset, mload(results))\n                let memPtr := add(resultsOffset, 0x40)\n                // Copy the current bytes from calldata to the memory.\n                calldatacopy(\n                    memPtr,\n                    add(o, 0x20), // The offset of the current bytes' bytes.\n                    calldataload(o) // The length of the current bytes.\n                )\n                if iszero(\n                    call(\n                        gas(), // Remaining gas.\n                        calldataload(targets.offset), // Address to call.\n                        mul(callvalue(), eq(results, lastResults)), // ETH to send.\n                        memPtr, // Start of input calldata in memory.\n                        calldataload(o), // Size of input calldata.\n                        0x00, // We will use returndatacopy instead.\n                        0x00 // We will use returndatacopy instead.\n                    )\n                ) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                // Advance the `targets.offset`.\n                targets.offset := add(targets.offset, 0x20)\n                // Append the current `resultsOffset` into `results`.\n                mstore(results, resultsOffset)\n                results := add(results, 0x20)\n                // Append the returndatasize, and the returndata.\n                mstore(memPtr, returndatasize())\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\n                // rounded up to the next multiple of 0x20.\n                resultsOffset := and(add(add(resultsOffset, returndatasize()), 0x3f), not(0x1f))\n                if iszero(lt(results, end)) { break }\n            }\n            // Restore the `sender` slot.\n            sstore(0, shl(160, 1))\n            // Direct return.\n            return(0x00, add(resultsOffset, 0x40))\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000},"viaIR":true,"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}}}}